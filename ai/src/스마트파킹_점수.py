# -*- coding: utf-8 -*-
"""스마트파킹_점수.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1EWGR4-_p1NJBNIaxMGaYNdby6TzeaGzZ
"""

import numpy as np
import pandas as pd
from xgboost import XGBRegressor
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler, OrdinalEncoder
from sklearn.metrics import mean_absolute_error, r2_score
import math
import json

# 1. 데이터 로드 및 전처리
df = pd.read_csv("서울시설공단_공영주차장 시간별 주차현황_20240331.csv", encoding="cp949")
df["시간대"] = pd.to_datetime(df["시간대"], format="%Y-%m-%d %H", errors='coerce')
df = df.dropna(subset=["시간대"])
df["시간"] = df["시간대"].dt.hour
df["요일"] = df["시간대"].dt.dayofweek
df["주차장명"] = df["주차장명"].str.strip().str.lower()
df["혼잡도(%)"] = ((df["입차대수"] - df["출차대수"]) / df["주차면수"]) * 100
df["혼잡도(%)"] = df["혼잡도(%)"].clip(0, 100)
df["지난주_혼잡도"] = df.groupby(["주차장명","요일","시간"])["혼잡도(%)"].shift(7*24)
df["지지난주_혼잡도"] = df.groupby(["주차장명","요일","시간"])["혼잡도(%)"].shift(2*7*24)
df["지지지난주_혼잡도"] = df.groupby(["주차장명","요일","시간"])["혼잡도(%)"].shift(3*7*24)
for col in ["지난주_혼잡도","지지난주_혼잡도","지지지난주_혼잡도"]:
    df[col] = df[col].fillna(df[col].groupby([df["주차장명"], df["요일"], df["시간"]]).ffill().fillna(df["혼잡도(%)"]).astype(float))
df = df.drop(columns=["시간대"])
for col in df.select_dtypes(["int64","float64"]):
    df[col] = df[col].astype("float32")

# 2. 특징 및 전처리
features = ["주차면수","입차대수","출차대수","지난주_혼잡도","지지난주_혼잡도","지지지난주_혼잡도","시간","요일"]
target = "혼잡도(%)"
X = df[features].copy()
y = df[target].copy()
ordinal_encoder = OrdinalEncoder()
X[["요일"]] = ordinal_encoder.fit_transform(X[["요일"]])
numerical_features = [f for f in features if f != "요일"]
scaler = StandardScaler()
X[numerical_features] = scaler.fit_transform(X[numerical_features])
fit_columns = X.columns.tolist()

# 3. 모델 학습
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)
best_model = XGBRegressor(n_estimators=300, max_depth=10, learning_rate=0.02, subsample=0.8, colsample_bytree=0.8, random_state=42)
best_model.fit(X_train, y_train)

# 4. 정적 정보 로드
df_static = pd.read_csv("서울시_공영주차장_최종.csv", encoding="cp949")
df_static["주차장명"] = df_static["주차장명"].str.strip().str.lower()

# 헬퍼 함수 정의
def haversine_distance(lat1, lon1, lat2, lon2):
    R = 6371.0
    phi1, phi2 = map(math.radians, (lat1, lat2))
    d_phi = math.radians(lat2 - lat1)
    d_lambda = math.radians(lon2 - lon1)
    a = math.sin(d_phi/2)**2 + math.cos(phi1)*math.cos(phi2)*math.sin(d_lambda/2)**2
    return R * 2 * math.asin(math.sqrt(a))

def calculate_expected_fee(row, parking_duration):
    기본_요금 = row.get("기본 주차 요금", 0) or 0
    기본_시간 = row.get("기본 주차 시간(분 단위)", 0) or 0
    추가_요금 = row.get("추가 단위 요금", 0) or 0
    추가_시간 = row.get("추가 단위 시간(분 단위)", 5) or 5
    일_최대 = row.get("일 최대 요금", 기본_요금) or 기본_요금
    if parking_duration <= 기본_시간:
        return 기본_요금
    초과 = parking_duration - 기본_시간
    단위수 = math.ceil(초과/추가_시간)
    fee = 기본_요금 + 단위수 * 추가_요금
    return min(fee, 일_최대)

def predict_congestion_for_parking(parking_name, weekday, hour):
    wd = (weekday - 1) % 7
    sample = df[df["주차장명"] == parking_name.strip().lower()]
    if sample.empty:
        return float(df["혼잡도(%)"].mean())
    filt = sample[(sample["요일"] == wd) & (sample["시간"] == hour)]
    vals = filt if not filt.empty else sample
    avg = vals[["주차면수","입차대수","출차대수","지난주_혼잡도","지지난주_혼잡도","지지지난주_혼잡도"]].mean()
    inp = pd.DataFrame({
        "주차면수": [avg["주차면수"]],
        "입차대수": [avg["입차대수"]],
        "출차대수": [avg["출차대수"]],
        "지난주_혼잡도": [avg["지난주_혼잡도"]],
        "지지난주_혼잡도": [avg["지지난주_혼잡도"]],
        "지지지난주_혼잡도": [avg["지지지난주_혼잡도"]],
        "시간": [hour], "요일": [wd]
    }).reindex(columns=fit_columns)
    inp[["요일"]] = ordinal_encoder.transform(inp[["요일"]])
    inp[numerical_features] = scaler.transform(inp[numerical_features])
    return float(best_model.predict(inp)[0])

def recommend_for_candidates(candidates, parking_duration=120, base_lat=37.450, base_lon=127.129):
    records = []
    for c in candidates:
        name = c["p_id"]; review = c.get("review",0); wd = c.get("weekday",1); hr = c.get("hour",0)
        cong = predict_congestion_for_parking(name, wd, hr)
        cong_score = np.clip(100-cong, 0, 100)
        row = df_static[df_static["주차장명"] == name.strip().lower()]
        if not row.empty:
            lat, lon = row[["위도","경도"]].iloc[0]
            dist = haversine_distance(base_lat, base_lon, lat, lon)
        else:
            dist = None
        fee = calculate_expected_fee(row.iloc[0] if not row.empty else {}, parking_duration)
        rev_score = np.clip(review,0,5)/5*100
        records.append({"p_id":name, "congestion_score":cong_score, "distance":dist, "fee":fee, "review_score":rev_score})
    fees = [r["fee"] for r in records if r["fee"] is not None]; dists = [r["distance"] for r in records if r["distance"] is not None]
    min_fee,max_fee = min(fees),max(fees); min_dist,max_dist = min(dists),max(dists)
    scenarios = {"혼잡도우선":{"w_cong":0.8,"w_dist":0.1,"w_fee":0.05,"w_rev":0.05},
                 "거리우선":{"w_cong":0.5,"w_dist":0.3,"w_fee":0.1,"w_rev":0.1},
                 "요금우선":{"w_cong":0.5,"w_dist":0.1,"w_fee":0.3,"w_rev":0.1},
                 "리뷰우선":{"w_cong":0.5,"w_dist":0.1,"w_fee":0.1,"w_rev":0.3}}
    results={}
    for key,w in scenarios.items():
        temp=[]
        for r in records:
            fee_s = (max_fee-r["fee"])/(max_fee-min_fee)*100 if max_fee>min_fee else 0
            dist_s = (max_dist-r["distance"])/(max_dist-min_dist)*100 if max_dist>min_dist else 0
            score = w["w_cong"]*r["congestion_score"]+w["w_dist"]*dist_s+ w["w_fee"]*fee_s+ w["w_rev"]*r["review_score"]
            temp.append({"p_id":r["p_id"],"score":score})
        results[key] = temp
    return results

# === 예시 입력 및 결과 출력 ===
if __name__ == "__main__":

    data = json.load(sys.stdin)
    candidates = data["candidates"]
    parking_duration = data.get("parking_duration", 120)
    base_lat = data.get("base_lat")
    base_lon = data.get("base_lon")

    # 추천 수행
    res = recommend_for_candidates(candidates, parking_duration, base_lat, base_lon)

    # 3) p_id 별로 4개 시나리오 점수를 하나의 dict 에 합치기
    combined = []
    # 예를 들어 혼잡도우선 리스트를 기준으로 루프
    for item in res["혼잡도우선"]:
        p = item["p_id"]
        entry = {
            "p_id": p,
            "주차장명": p,
            "혼잡도우선": round(item["score"], 2)
        }
        # 나머지 시나리오 점수도 동일 p_id 에서 찾아 넣기
        for scenario in ["거리우선", "요금우선", "리뷰우선"]:
            score = next(x["score"] for x in res[scenario] if x["p_id"] == p)
            entry[scenario] = round(score, 2)
        combined.append(entry)

    # 4) JSON 으로 한 번에 출력
    json.dump(combined, sys.stdout, ensure_ascii=False)
